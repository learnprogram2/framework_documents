



**结合业务理解和考察设计模式**



### 029. 迭代器模式: 封装你的集合迭代逻辑

**面向Iterator接口编程**，无论底层的数据结构和迭代算法如何变化，调用者都不用修改代码

- **应用: smcp/cusip之类的key/index数据量变化很多, 放在map里, 之前是单个数组, 可以使用迭代器**

```java
// 债券产品的 不同渠道key, index 遍历.
class ProductKeys implement MyKeys{
    public Iterator iterator() {
        return new KeysIterator(this);
    }
}    
class ClassroomIterator implement Iterator {
    private int index;
    private MyKeys keys;
    public ClassroomIterator(MyKeys keys) {
        this.keys = keys;
    }
    public boolean hasNext() {
        return index >= keys.size() - 1;
    }
    public Object next() {
        return keys.get(index ++);
    }
}
```



### 030. 适配器模式: 适配多版本接口和第三方接口



```java
// 1. 多版本, 第三方的具体实现, 可能由worker2,3,4...
class Worker {
    public void walk(){
        System.out.println("到目的地走路去.");
    }
}
// 2. 适配器接口, 给用户用
interface GoToDestination {
	// 去目的地
    void go();
}
// 3. 负责代理的适配器实现
class Adapter {
    private Worker worker;
    public Adapter(Worker worker) {
        this.worker = worker;
    }
    public void go() {
        // 准备判断校验.
        worker.go();
    }
}
```



### 031. template_method 模板方法模式: 将部分特殊实现交给子类

**多个同类型的方法/类, 共有通用的基础逻辑.** 不要复制粘贴, 抽取template_method

```java
abstract class WorkerTemplate {
	public void common(){
        System.out.println("this is our common step");
    }
}

class WorkerA extends WorkerTemplate{
    public void work(){
        common();
        System.out.println("do workerA's job");
    }
}
```



### 032. simple_factory 简单工厂: 是个人都会的设计模式

**创建对象不只需要new, 还需要做一些其他的准备才能拿到需要的对象. 所以用工厂更方便.**

spring就是一个大工厂

```java
class Product {
    // content of product
}
class Factory {
    public static Product create(){
        // prepare, create, process, return
    }
}
// 用的时候拿就好了.
```







### 034. abstract_factory 抽象工厂模式: simple_factory变种

简单工厂模式-> **需要生产多个产品组合了: A+B, B+C, C+A 三种产品组合.**

如果用简单工厂, 就需要用工厂创建A, 创建B, 手动组合. 这个组合过程就变得common了.

如果A变了, B变了, 那么common逻辑就变了. 

A组合B, B组合C, .... 这些组合和组合的准备

```java
public interface AbstractFactory {
    ProductA createProductA();
    ProudctB createProudctB();
}
public class FactoryImpl1 implements AbstractFactory {
    public ProductA createProductA() {
        return new ProductAImpl1();
    }
    public ProductB createProductB() {
        return new ProductBImpl1();
    }
}
public class FactoryImpl2 implements AbstractFactory {
    public ProductA createProductA() {
        return new ProductAImpl2();
    }
    public ProductB createProductB() {
        return new ProductBImpl2();
    }
}

// 操作FactoryImpl1就是拿到A+B组合, 操作FactoryImpl2就是另一个组合
// 修改facotryImpl就可以.
```



### 035. 单例模式: 一个类只有一个实例

- 配置类
- 工厂类
- 分类:
  - 饱汉模式: 用的时候再创建
  - 饿汉模式: 上来就创建

- **另外分线程安全与否:**

  - double-check + volatile: 禁止指令重排, 保证instance!=null的时候能拿到Object对象.

  - 静态内部类: 

    ```java
    class Singleton {
     	public static class InnerHolder {
            private static Singleton single = new Singleton();
        }   
        public Singleton get() {
            // 静态内部类, 执行到InnerHolder的时候才会初始化这个类, 类加载机制.
            return InnerHolder.single;
        }
    }
    ```





### 036. facade 外观/门面模式: 多个内部模块封装在一个类里

系统A有多个接口, 其他系统要用, 这些接口有一些互相依赖的处理作用, 可以做一个门面facade, 其它系统用就好了. 

和代理不一样, 代理是用户. 门面是生产者的.

service的API其实就是数据库/多种操作的门面. facade包装每个子系统内部的大量代码组件，对外暴露统一简单的接口

```java
public class SystemAFacade {
    
    public static void operate() {
        ModuleA moduleA = new ModuleAImpl();
        moduleA.operate();
        
        ModuleB moduleB = new ModuleBImpl();
        moduleB.operate();
        
        ModuleC moduleC = new ModuleCImpl();
        moduleC.operate();
    }
    
}
public class SystemB {
    
    public static void main(String[] args) {
        SystemA.operate();
    }
    
}
```



### 037. 构造器 builder模式: 封装复杂对象的构造逻辑

**对象构造有可能需要很多属性设置, 校验, 甚至依赖其他系统, 把这个逻辑抽出一个builder**

- 构建逻辑复杂, 封装带builder, 具体步骤, 代码逻辑清晰
- 将构建步骤, 封装到director, 面向builder接口编程.
- 相对于工厂, director和builder创造更好更灵活的逻辑



### 038. 原型 prototype模式: 实现自己的对象拷贝逻辑

如果要拷贝一个对象, 以他为原型, 拿到另一个完全相同的, 就是原型.

**在类里面实现clone()方法**

- 深拷贝
- 浅拷贝. 会扰乱其他对象

不用维护克隆的逻辑了.

**可以实现对象属性拷贝的工具类, 改造: 发货单的clone()方法拷贝出货单.** 



### 039. mediator 中介者模式: 互相调用的模块之间解耦合

- 创建mediator包含所有model实例. 
- modelA通过mediator调用modelB.

`mediator.callModelB(param);`

感觉是大家的总代理. 门面是producer的, 代理是user的, mediator是大家的.

**实际应用:** **MQ解耦API. 如果调用modelB, 那么发送一个mq队列里, modelB就是另一端. MQ就是mediator**



### 040. proxy 代理模式: 本地接口代理远程调用

```java
interface Worker {
    void work();
}
class WorkerA implement Worker{
    public void work(){
        // do work
    }
}
class Proxy implement Worker {
    private Worker worker;
    public void work() {
        // 1. 做好多自己的代理增强事情
        // 2. 调用真正工作的.
        worker.work();
    }
}
```

- 懒加载场景用动态代理实现
- 远程调用, 分布式远程调用大量使用代理.





### 041. 























