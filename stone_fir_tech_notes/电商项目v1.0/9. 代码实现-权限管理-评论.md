## 110-112. 权限管理模块



### 110. 权限管理模块代码骨架





### 111. 不同分层POJO间的数据拷贝-原型, beanCopier-享元

**DO数据转到DTO的时候要拷贝**, 还有DO到BO的转变

```java
// 1. 原型模式 拷贝
class PriorityDO() {
    // 2. 享元模式-可以抽工具类
    private static BeanCopier bc = new BeanCopier();
    // 各种属性
    // clone方法
    protected <T> T clone(Class<T> toClass) {
        T toObject = toClass.newInstance();
        // 从from(自己)拷贝到to: 
        // 1. 可以用 BeanProperties... 之类的反射属性拷贝
        // 2. cglib的动态代理属性拷贝beanCopier-更快
        return to;
    }
}
// 使用
PriorityDTO c = priorityDO.clone(PriorityDTO.class);
```

- **维护一个commonAPI的branch来做这种工具类的创建.** 其他需要就从common里面拉取. 

  可以把beanCopier提取出来做工具类.





### 112. 权限管理模块的CRUD



### 113. 权限删除功能- 基于组合模式+访问者模式

**组合模式:** 将树形数据结构拼接起来, 对每个结点的操作可以直接递归到每一个节点.

**访问者模式:** 对数据结构要执行的操作,  把具体操作封装成访问者, 访问者接收对象, 进去迭代访问就可以了. 

- 访问者模式: 组合模式

```java
// A. 组合模式: 组装树/能够组合树状结构就可以
class PriorityNode {
    private Long parentId;
    private List<PriorityNode> children = new ArrayList<PriorityNode>();
    
    // B.0 访问者模式入口
    public void accept(Visitor visitor){
        visitor.visit(this);
    }
}
// B. 访问者模式
interface Visitor {
    void visit(PriorityNode node);
}
class RemoveAllVisitor implement Visitor {
    public void visit(PriorityNode node) {
        // 1. 迭代到子节点, 保证每个节点都被visited
        for (PriorityNode child : getAllChild(node)) {
            
        }
        // 2. 执行当前节点的visit操作.
        removeChild(node);
    }
    public void removeChild(PriorityNode node) {
        //...
    }
}
// 使用
priorityNode.accept(new RemoveAllVisitor());
```





## 评论模块

### 114. 梳理相关技术问题

1. 定时好评
   - 定时任务调度. 
   - 订单里面添加冗余字段是否有评论. 





### 115. 手动发表评论代码编写

```java
// 1. 每个单独的enum变量都出出来一个类 constant/enum都可以.
public class DefaultComment {
	public static final Integer YES = 1;
	public static final Integer NO = 0;	
}

```





### 116. 自动发表评论代码编写





## 商品中心模块

### 117.  商品中心属性管理模块代码



### 118. 完成加入购物车代码



### 119-120. 加入购物车功能的 单元测试&冒烟测试

**单元测试:** 简单的单元测试

**冒烟测试:** 把系统跑起来, 然后执行一些请求看看能不能运行. 但考虑到依赖的其它系统, 可以使用RunWith这种模拟启动.





## 库存管理

### 121. 库存管理功能- 模板-命令-工厂模式



不同的命令就是具体的逻辑不同，但是可以用同一个执行类来执行这个command，用这个StockUpdaterInvoker来执行这个不同的command

工厂方法模式来创建出这些command

原型模式，创建采购入库单的时候，获取到的是一个采购单，此时你可能需要将采购单的数据拷贝一份到采购入库单中去

责任链模式，可以运用到wms中心的采购入库单完成审核的业务流程中去，形成一个业务处理流程的链条，后面我们如果要对这个业务流程做增加一个环节，删除一个环节，修改一个环节，重新组装一个业务流程，都很方便



- 模板方法: **抽象类, 把公共逻辑提取出来**, 具体实现看子类里的设计模式.

- **命令模式:** 调用的都是父类的命令. 复用的公用执行逻辑, 用模板方法实现命令模式, 用工厂方法模式创建不同命令.
- **工厂模式**: 用的是简单工厂, 负责创建的参数准备.



```java
// 1. 命令接口
class interface StockUpdateCommand {
    boolean updateStock();
}
// 2. 命令接口模板
abstract class AbstractStockUpdateCommand implements StockUpdateCommand {
    // 库存更新需要的数据
    protected List<StockDO> stockDOList;
    protected StockDAO stockDAO;
    protected DateProvider dateprovider;
    public AbsctractStockUpdateCommand(List<StockDO> stockDOList, StockDAO stockDAO, DateProvider dateprovider) {
        this.stockDOList = stockDOList;
        this.stockDAO = stockDAO;
        this.dateprovider = dateprovider;
    }
    @Override
    public boolean updateStock() {
        // steps
		updateSaleStockQuantity();
		updateLockedStockQuantity();
		updateSaledStockQuantity();
		updateStockStatus();
		updateGmtModified();
		executeUpdateGoodsStock();
    }
    void updateSaleStockQuantity();
    void updateLockedStockQuantity();
    void updateSaledStockQuantity();
    void updateStockStatus();
    void updateGmtModified();
    void executeUpdateGoodsStock();
}
// 3. 命令实现类
class PurchaseInputStockUpdateCommand extends AbstractStockUpdateCommand {
    // 实现具体的功能方法
    @Override
	protected void updateSaleStockQuantity() throws Exception {
		for(GoodsStockDO goodsStockDO : goodsStockDOs) {
            // do something
		}
	}
	// 选择要实现的步骤
}
// 4. 命令class的工厂方法模式接口
interface StockUpdateCommandFactory<T> {
    StockUpdateCommand create(T parameter);
}
// 5. 工厂抽象类
abstract class AbstractStockUpdateCommandFactory<T> {
    // command需要的属性
    protected StockDAO stockDAO;
    protected DateProvider dateprovider;
    @Override
    public GoodsStockUpdateCommand create(T parameter) {
		try {
			// 做一些校验, 配置属性.
            // 调用子的
            return create(goodsStockDOs, parameter); 
		} catch (Exception e) {
			logger.error("error", e); 
		}
		return null;
	}
	abstract StockUpdateCommand create(List<GoodsStockDO> goodsStockDOs, 
                                            T parameter) throws Exception;
}
// 6. 工厂实现类.
class PurchaseInputStockUpdateCommandFacotry extends AbstractStockUpdateCommandFactory {
    // 构造器调用父和自己的属性,
    public PurchaseInputStockUpdateCommandFacotry(xxx){
        super(xxx);
        ///
    }
    @Override
	public StockUpdateCommand create(List<GoodsStockDO> goodsStockDOs, 
                                            T parameter) throws Exception{
        // 根据参数组装 PurchaseInputStockUpdateCommand
        return new PurchaseInputStockUpdateCommand(xxxxxx);
    }

}
// 7. 使用:
//// 这是stock update的命令, 也可以有同一套的其它update命令逻辑, 同一套意味着<命令,简单工厂>的体系实现.
@Autowired
PurchaseInputStockUpdateCommandFacotry factory;
StockUpdateCommand command = factory.create(xxx);
command.updateStock();
```



### 122. 第一周第二天的站立会

昨天进度, 昨日问题, 今日要做什么.





## 123-129 权限管理模块-评论模块 的单元测试和冒烟测试

## 130-132 属性管理, 购物车, 库存管理 的开发





## 133-135 中介者, 观察者, 备忘录 模式应用

- **中介者: 组件之间的调用解耦, a调用中介者, 中介者调用b.** 

  **实际使用: 队列**, a写入队列, b从队列里消费. 内存队列/MQ.

- **观察者模式: 拿到异步结果通知.  **

  实际使用: **监听器**

- **备忘录:** 想要用原来的meta 数据, 需要把meta数据暂存起来. 

  实际使用: **jvm内的用阻塞队列, 在满了之后暂存到磁盘.** 使用MQ时在MQ不可用时候也固化消息.



### 133. 中介者模式 - 异步通知更新缓存

- 库存中心通知调度中心的时候可以异步. 

内存队列: 实现一个包装类, 维护一个ArrayBlockingQueue就好了. 代理模式.

### 134. 观察者模式 - 获取异步处理结果

```java
// A. 如果是分布式, 就用zookeeper.
// B. JVM内
class JobObserver implements Observer {
    public void update(Observable o, Object arg) {
        // 事件来了.
    }
}
class JobObservable implements Observable {
	public void setResult(Boolean result) {
		GoodsStockUpdateResult goodsStockUpdateResult = 
            new GoodsStockUpdateResult();
		goodsStockUpdateResult.setMessageId(messageId); 
		goodsStockUpdateResult.setResult(result); 
		this.setChanged();
		this.notifyObservers(goodsStockUpdateResult);  
	}
}
// 使用
JobOvervable jo = new JobObservable();
jo.setObserver(new JobObserver);
job.setResult();
```





### 135. 备忘录模式 - 离线存储队列阻塞的数据

内存队列满了之后写到MySQL表里面.

之后如果写入内存队列, 要看一下MySQL里面有没有需要补偿的.















.

## 146 原型模式

### 146. 原型模式来做深度克隆功能





## 161 策略模式-抽象工厂 TODO

- 策略模式: 替换掉复杂的IF-ELSE.
- 抽象工厂: 生产多种对象组合.
- 策略模式与命令模式的区别: 策略模式是通过不同的算法做同一件事情, 而命令模式则是通过不同的命令做不同的事情，常含有(关联)接收者.

### 161. 策略模式与抽象工厂模式 完成价格计算功能

对一个商品计算价格, 它有一套策略:

- **总金额计算策略+促销活动处理策略+运费计算策略**

  不同情况可以组成的多种策略组合包.

- 多个策略->策略模式, 策略的组合包->抽象工厂模式.

```java

/**
 * 计算订单价格
 * @param order 订单
 */
public OrderInfoDTO calculateOrderPrice(OrderInfoDTO order) {
	// 定义订单的各种价格
	Double totalAmount = 0.0;
	Double discountAmount = 0.0;
	Double freight = 0.0;
	
	for(OrderItemDTO item : order.getOrderItems()) {
		// 查询订单条目使用的促销活动
		PromotionActivityDTO promotionActivity = promotionService.getById(
				item.getPromotionActivityId());
		
		// 根据促销活动获取到订单计算组件的工厂
		OrderPriceCalculatorFactory orderPriceCalculatorFactory = 
				getOrderPriceCalculatorFactory(promotionActivity); 
		
		// 从订单计算组件工厂中获取一套订单的价格计算组件
		TotalPriceCalculator totalPriceCalculator = orderPriceCalculatorFactory
				.createTotalPriceCalculator();
		PromotionActivityCalculator promotionActivityCalculator = orderPriceCalculatorFactory
				.createPromotionActivityCalculator(promotionActivity); 
		FreightCalculator freightCalculator = orderPriceCalculatorFactory
				.createFreightCalculator();
		
		// 计算订单条目的总金额
		totalAmount += totalPriceCalculator.calculate(item);
		
		// 处理促销活动，计算促销活动的减免金额，以及促销活动的赠品
		PromotionActivityResult result = promotionActivityCalculator.calculate(
				item, promotionActivity); 
		discountAmount += result.getDiscountAmount();
		order.getOrderItems().addAll(result.getOrderItems());
		
		// 计算订单条目的运费
		freight += freightCalculator.calculate(item, result);
	}
	
	// 给订单设置计算后的结果（同时已经包含了所有的赠品）
	order.setTotalAmount(totalAmount);
	order.setDiscountAmount(discountAmount); 
	order.setFreight(freight); 
	
	return order;
}

/**
 * 获取一个订单价格计算工厂
 * @param promotionActivityType 促销活动类型
 * @return 订单价格计算工厂
 */
private OrderPriceCalculatorFactory getOrderPriceCalculatorFactory(
		PromotionActivityDTO promotionActivity) {
	if(promotionActivity == null) {
		return defaultOrderPriceCalculatorFactory;
	}
	
	Integer promotionActivityType = promotionActivity.getType();
	
	if(PromotionActivityType.DIRECT_DISCOUNT.equals(promotionActivityType) 
			|| PromotionActivityType.MULTI_DISCOUNT.equals(promotionActivityType)
			|| PromotionActivityType.REACH_DISCOUNT.equals(promotionActivityType)) {  
		return discountOrderPriceCalculatorFactory;
	} else {
		return giftOrderPriceCalculatorFactory;
	}
}
```









## 164-165 访问者模式, 享元模式

### 164. 基于访问者模式完成权限控制模块



### 165. 基于享元模式 实现全线数据的缓存与刷新









