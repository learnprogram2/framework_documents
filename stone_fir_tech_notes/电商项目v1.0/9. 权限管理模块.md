## 110-112. 权限管理模块



### 110. 权限管理模块代码骨架





### 111. 不同分层POJO间的数据拷贝-原型, beanCopier-享元

**DO数据转到DTO的时候要拷贝**, 还有DO到BO的转变

```java
// 1. 原型模式 拷贝
class PriorityDO() {
    // 2. 享元模式-可以抽工具类
    private static BeanCopier bc = new BeanCopier();
    // 各种属性
    // clone方法
    protected <T> T clone(Class<T> toClass) {
        T toObject = toClass.newInstance();
        // 从from(自己)拷贝到to: 
        // 1. 可以用 BeanProperties... 之类的反射属性拷贝
        // 2. cglib的动态代理属性拷贝beanCopier-更快
        return to;
    }
}
// 使用
PriorityDTO c = priorityDO.clone(PriorityDTO.class);
```

- **维护一个commonAPI的branch来做这种工具类的创建.** 其他需要就从common里面拉取. 

  可以把beanCopier提取出来做工具类.





### 112. 权限管理模块的CRUD



### 113. 权限删除功能- 基于组合模式+访问者模式

**组合模式:** 将树形数据结构拼接起来, 对每个结点的操作可以直接递归到每一个节点.

**访问者模式:** 对数据结构要执行的操作,  把具体操作封装成访问者, 访问者接收对象, 进去迭代访问就可以了. 

- 访问者模式: 组合模式

```java
// A. 组合模式: 组装树/能够组合树状结构就可以
class PriorityNode {
    private Long parentId;
    private List<PriorityNode> children = new ArrayList<PriorityNode>();
    
    // B.0 访问者模式入口
    public void accept(Visitor visitor){
        visitor.visit(this);
    }
}
// B. 访问者模式
interface Visitor {
    void visit(PriorityNode node);
}
class RemoveAllVisitor implement Visitor {
    public void visit(PriorityNode node) {
        // 1. 迭代到子节点, 保证每个节点都被visited
        for (PriorityNode child : getAllChild(node)) {
            
        }
        // 2. 执行当前节点的visit操作.
        removeChild(node);
    }
    public void removeChild(PriorityNode node) {
        //...
    }
}
// 使用
priorityNode.accept(new RemoveAllVisitor());
```





## 评论模块

### 114. 梳理相关技术问题

1. 定时好评
   - 定时任务调度. 
   - 订单里面添加冗余字段是否有评论. 





### 115. 手动发表评论代码编写

```java
// 1. 每个单独的enum变量都出出来一个类 constant/enum都可以.
public class DefaultComment {
	public static final Integer YES = 1;
	public static final Integer NO = 0;	
}

```





### 116. 自动发表评论代码编写





## 商品中心模块

### 117.  商品中心属性管理模块代码



### 118. 完成加入购物车代码



### 119-120. 加入购物车功能的 单元测试&冒烟测试

**单元测试:** 简单的单元测试

**冒烟测试:** 把系统跑起来, 然后执行一些请求看看能不能运行. 但考虑到依赖的其它系统, 可以使用RunWith这种模拟启动.





## 库存管理

### 121. 库存管理功能- 模板-命令-工厂模式



不同的命令就是具体的逻辑不同，但是可以用同一个执行类来执行这个command，用这个StockUpdaterInvoker来执行这个不同的command

工厂方法模式来创建出这些command

原型模式，创建采购入库单的时候，获取到的是一个采购单，此时你可能需要将采购单的数据拷贝一份到采购入库单中去

责任链模式，可以运用到wms中心的采购入库单完成审核的业务流程中去，形成一个业务处理流程的链条，后面我们如果要对这个业务流程做增加一个环节，删除一个环节，修改一个环节，重新组装一个业务流程，都很方便



- 模板方法: **抽象类, 把公共逻辑提取出来**, 具体实现看子类里的设计模式.

- **命令模式:** 调用的都是父类的命令. 复用的公用执行逻辑, 用模板方法实现命令模式, 用工厂方法模式创建不同命令.
- **工厂模式**: 用的是简单工厂, 负责创建的参数准备.



```java
// 1. 命令接口
class interface StockUpdateCommand {
    boolean updateStock();
}
// 2. 命令接口模板
abstract class AbstractStockUpdateCommand implements StockUpdateCommand {
    // 库存更新需要的数据
    protected List<StockDO> stockDOList;
    protected StockDAO stockDAO;
    protected DateProvider dateprovider;
    public AbsctractStockUpdateCommand(List<StockDO> stockDOList, StockDAO stockDAO, DateProvider dateprovider) {
        this.stockDOList = stockDOList;
        this.stockDAO = stockDAO;
        this.dateprovider = dateprovider;
    }
    @Override
    public boolean updateStock() {
        // steps
		updateSaleStockQuantity();
		updateLockedStockQuantity();
		updateSaledStockQuantity();
		updateStockStatus();
		updateGmtModified();
		executeUpdateGoodsStock();
    }
    void updateSaleStockQuantity();
    void updateLockedStockQuantity();
    void updateSaledStockQuantity();
    void updateStockStatus();
    void updateGmtModified();
    void executeUpdateGoodsStock();
}
// 3. 命令实现类
class PurchaseInputStockUpdateCommand extends AbstractStockUpdateCommand {
    // 实现具体的功能方法
    @Override
	protected void updateSaleStockQuantity() throws Exception {
		for(GoodsStockDO goodsStockDO : goodsStockDOs) {
            // do something
		}
	}
	// 选择要实现的步骤
}
// 4. 命令class的工厂方法模式接口
interface StockUpdateCommandFactory<T> {
    StockUpdateCommand create(T parameter);
}
// 5. 工厂抽象类
abstract class AbstractStockUpdateCommandFactory<T> {
    // command需要的属性
    protected StockDAO stockDAO;
    protected DateProvider dateprovider;
    @Override
    public GoodsStockUpdateCommand create(T parameter) {
		try {
			// 做一些校验, 配置属性.
            // 调用子的
            return create(goodsStockDOs, parameter); 
		} catch (Exception e) {
			logger.error("error", e); 
		}
		return null;
	}
	abstract StockUpdateCommand create(List<GoodsStockDO> goodsStockDOs, 
                                            T parameter) throws Exception;
}
// 6. 工厂实现类.
class PurchaseInputStockUpdateCommandFacotry extends AbstractStockUpdateCommandFactory {
    // 构造器调用父和自己的属性,
    public PurchaseInputStockUpdateCommandFacotry(xxx){
        super(xxx);
        ///
    }
    @Override
	public StockUpdateCommand create(List<GoodsStockDO> goodsStockDOs, 
                                            T parameter) throws Exception{
        // 根据参数组装 PurchaseInputStockUpdateCommand
        return new PurchaseInputStockUpdateCommand(xxxxxx);
    }

}
// 7. 使用:
//// 这是stock update的命令, 也可以有同一套的其它update命令逻辑, 同一套意味着<命令,简单工厂>的体系实现.
@Autowired
PurchaseInputStockUpdateCommandFacotry factory;
StockUpdateCommand command = factory.create(xxx);
command.updateStock();
```



### 122. 第一周第二天的站立会

昨天进度, 昨日问题, 今日要做什么.









